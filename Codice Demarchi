//Begin page main
bool itemChosen;
int fase, sottofase, ID, BoR,counter;
float vai[3], zona[4], speed, stato[12], statoAvv[12], facing[3], posAvv[3], vel[3], oggetto[3], distPrec;

//FUNZIONE PER RACCOLTA DATI
/*
-input: non riceve alcun dato esterno
-output: non ritorna valori
-funzionalitÃ :  _Aggiorna i propri dati e quelli dell'avversario, riguardanti la posizione, la velocitÃ  e dove sto guardando.
                _Tiene sotto controllo quali sono gli oggetti che abbiamo e quelli che non abbiamo, in base alla loro presenza nella zona
                 di scarico o se li stiamo trasportando.
                 Nel caso che non siano presenti nella zona o non li abbiamo con noi, li segna non presenti
*/
void getDati()
{
    api.getMyZRState(stato);
	api.getOtherZRState(statoAvv);
	
	for(int i = 0; i < 3; i++)
	{
		facing[i] = stato[i + 6];
		posAvv[i] = statoAvv[i];
		vel[i] = stato[i + 3];
	}
	
	speed = mathVecMagnitude(vel,3);
	
	

}
//FUNZIONE PER SETTARE UN VETTORE
/*
-input: _float v[] = Vettore al quale assegniamo i valori di x, y e z
        _float x = Valore della coordinata x
        _float y = Valore della coordinata y
        _float z = Valore della coordinata z
-output: non ritorna direttamente valori, ma modifica il vettore passato con i valori di v[]
-descrizione:   _Assegno a v[] nelle sue diverse posizioni, le coordinate passate nei parametri seguendo questo ordine:
                v[0] = x / v[1] = y / v[2] = z
*/
void setV(float v[],float x,float y,float z)/*Definitivo*/
{
	v[0] = x;
	v[1] = y;
	v[2] = z;
}
//FUNZIONE PER CALCOLARE UNA DISTANZA
/*
-input: _float a[] = Primo punto
        _float b[] = Secondo punto
-otuput: _Ritorna un valore float unico equivalente alla distanza dal punto "a" al punto "b"
-descrizione:   _Tramite una formula matematica, calcola la distanza fra il punto "a" e il punto "b"
*/
float dist(float a[],float b[])/*Definitivo*/
{
	return sqrt(mathSquare(a[0] - b[0]) + mathSquare(a[1] - b[1]) + mathSquare(a[2] - b[2]));
}
//FUNZIONE PER IL MOVIMENTO
/*
-input:     non assume alcun valore in input
-output:    non ritorna alcun valore in output
-descrizione:   _All'inizio della funzione "muovi" viene inizializzato un vettore "vec" al quale viene assegnato la differenza tra la posizione
                del nostro satellite al punto al quale dobbiamo arrivare. Viene utilizzato nella funzione "setVelocityTarget"
                
                _Nell'"if" controlliamo se abbiamo rilasciato tutti gli SPS:
                
                    _se SÃ¬: 
                            _Nel caso che ci manchi l'oggetto, ci muoviamo verso la posizione definita dall'ID 
                                (trovato tramite la funzione itemPriority, richiamata nel loop).
                                Durante il movimento, teniamo conto della nostra velocitÃ  e la nostra distanza rispetto all'oggetto:
                                
                                    _se la distanza Ã¨ maggiore del raggio massimo: _Ci muoviamo verso la posizione dell'oggetto
                                    _altrimenti se la velocitÃ  Ã¨ maggiore di 0.01 m/s, rallentiamo
                                    
                                Questo ci aiuta a prendere l'oggetto molto velocemente.
                                
                            _Nel caso che avessimo l'oggetto, richiamiamo la funzione "dropItem", la quale individuerÃ  la posizione della zona
                                attribuendola al vettore "vai" e controllerÃ  la funzione di drop dell'oggetto, che avverrÃ  quando le condizioni 
                                interne di "dropItem" saranno soddisfatte.
                                DopodichÃ¨:
                                
                                    _se la distanza dalla zona di scarico Ã¨ minore di 0.13m, il satellite rallenta o rimane fermo
                                    _altrimenti, viaggia verso la posizione della zona di drop
                                    
                            _Nel caso in cui l'avversario ha l'oggetto che noi dovremmo prendere, ri-scegliamo quale oggetto prendere
                            
                            _Alla fine, richiamiamo la funzione "ruota()", che in questo caso va eseguito sempre, poichÃ¨ abbiamo necessitÃ 
                            di avere il satellite rivolto costantemente verso l'oggetto o la zona di scarico
                            
                    _se No: 
                            _Dopo aver assegnato nel "loop" il punto in cui dirigermi per rilasciare il primo/secondo/terzo SPS
                            controllo la distanza del nostro satellite da tale punto:
                            
                                _se la distanza Ã¨ minore di 0.13m, il satellite rallenta
                                _se la distanza Ã¨ maggiore di 0.60m, il satellite utilizzerÃ  la funzione "setVelocityTarget"
                                per muoversi velocemente verso il punto
                                _se la distanza Ã¨ compresa fra 0.13m e 0.60m, il satellite utilizza "setPositionTarget" per rallentare
                                prima di arrivare al punto e evitare quindi di mancarlo
                            
*/
void muovi(int fase,int sottofase)
{
    float vec[3],d;
	mathVecSubtract(vec,vai,stato,3);
	d=dist(vai, stato);
	//Se sto per finire il carburante, mi fermo
	//Vedere se è il caso di fermarsi nella propria zona di assemblaggio
	if (game.getFuelRemaining()<2) {
	    api.setPositionTarget(stato);
	    DEBUG (("Mi fermo perche' sto finendo carburante"));
	}
	else {
	if (fase==0)
	{
		//Mi muovo verso un SPS
		spinta(d);
    }
	}
	else {
        if (sottofase == 0)
        {   
            //Mi muovo verso un oggetto scelto
            //if (dist(vai, stato) > R[game.getItemType(ID)])
            if (dist(vai, stato) > 0.23)
                api.setPositionTarget(vai);
                
            else {
                DEBUG(("Sono in zona di dock   vel: %f",speed));
                if (speed > 0.01) 
                    api.setPositionTarget(stato);
            }
        }
        else {
            // Mi muovo per posare un oggetto
	 		if (dist(vai, stato) < 0.12)
            	api.setPositionTarget(stato);
            else 
                api.setPositionTarget(vai);
        }    
        ruota();    //Serve ruotare se mi hanno fregato l'oggetto?
	}
	
	        
}

void spinta (float d) {
    if (counter<10||d>distPrec) {
        api.setVelocityTarget(vec);
        DEBUG (("Spingo"));
        if (d>distPrec) counter=0;
        counter++;
    }
	else
        DEBUG (("Vado per inerzia"));
	if (d < 0.13)
        api.setPositionTarget(stato);
    else 
        api.setPositionTarget(vai);
    }
}
//FUNZIONE PER LA ROTAZIONE
/*
-input: non riceve alcun valore in input
-output: non ritorna alcun valore in output
-descrizione:   _Viene inizializzato un vettore float "vett"
                _Viene eseguito il calcolo matematico con le varie assegnazioni per trovare il vettore normalizzato
                _Viene richiamata la funzione "setAttitudeTarget" immettendo come parametro il vettore normalizzato
                cosÃ¬ facendo il satellite ruota fino a guardare il punto calcolato
*/
void ruota()
{
    float vett[3];
    
    mathVecSubtract(vett,vai,stato,3);
    mathVecNormalize(vett,3);
    api.setAttitudeTarget(vett);
}
//FUNZIONE PER L'ESECUZIONE DEL DOCKING
/*
-input: non riceve alcun valore in input
-output: ritorno true se il dock è riuscito, altrimenti false
-descrizione:   _All'interno del parametro dell'if, richiamiamo "checkDock()", che ritornerÃ  un valore booleano:
                    _se checkDock() = true:
                                            _Eseguo il dock dell'item tramite la funzione "dockItem(ID)"
                    _se checkDock() = false:
                                            _Non eseguo alcuna operazione fino a quando checkDock non ritornerÃ  "true"
*/
bool dock()
{
    if (checkDock()) {
        game.dockItem(ID);
        DEBUG (("Stato oggetto %d :%d",ID,game.hasItem(ID)));
        /*Questa parte servirebbe per sgnaciare ultimo SPS vicino al primo
            LARGE da prendere; da studiare, perchè così aumenta SPS error
        //Se non ho ancora sganciato l'ultimo SPS lo sgancio
        if (game.getNumSPSHeld()>0) {
            game.dropSPS();
            DEBUG (("Ultimo SPS   ID: %d",ID));
            // Preleva i dati della zona
            game.getZone(zona);
        } */
        return true;
    }
    else
        return false;
}
//FUNZIONE PER IL CONTROLLO DELLA POSSIBILITA' DI DOCKING
/*
-input: non riceve alcun valore in input
-output:    _true = Ã¨ possibile eseguire il docking
            _false = non Ã¨ possibile eseguire il docking
-descrizione:   _Uno switch permette di controllare, in base all'ID scelto tramite l'"itemPriority", quali sono i range e la velocitÃ 
                a cui Ã¨ consentito il docking (in base al tipo di oggetto):
                
                _Se questi range vengono rispettati, la funzione ritorna "true"
                _Se questi range non vengono rispettati, ritorna "false"
*/
bool checkDock()
{
    float distdock [6][2] = {	{.151,.173}, {.151,.173},
                               	{ .138 , .160 },{ .138 , .160 },
                          		{ .124 , .146 },{ .124 , .146 } 
    };
    return (dist(stato, vai)>distdock[ID][0] && dist(stato, vai)< distdock[ID][1] && speed < .01? 
	true : false );
}
//FUNZIONE PER LA SCELTA DELL'OGGETTO
/*
-input:     non assume alcun valore in input
-output:    non ritorna alcun valore
-descrizione:   Comincio con vedere se ho tutti e 2 i gialli;se è cosi passo ai 
                MEDIUM,ecc.
                La funzione scelgoQuale determina quale dei 2 oggetti di un 
                determinato tipo conviene andare a prendere 
*/
void itemPriority()
{
    //Se nella zona non ho già entrambi i LARGE o devo sganciare terzo SPS, devo andare a prendere un LARGE 
	if ( ! (game.itemInZone(0) && game.itemInZone(1)) || game.getNumSPSHeld()>0) {
		//Devo andare a prendere un LARGE
		scelgoQuale(0);	//alla funzione passo l'ID del primo dei 2 oggetti LARGE
	}
	else {
		//Se nella zona non ho già entrambi i MEDIUM, devo andare a prendere un MEDIUM
		if ( ! (game.itemInZone(2) && game.itemInZone(3))) {
			//Devo andare a prendere un MEDIUM
			scelgoQuale(2);	//alla funzione passo l'ID del primo dei 2 oggetti MEDIUM		
		}
	}
	game.getItemLoc(vai, ID);
	
}
//FUNZIONE PER LA SCELTA TRA I 2 OGGETTI DI UN CERTO TIPO
/*
-input:     numero del primo oggetto di quel tipo
-output:    non ritorna alcun valore
-descrizione:   - se ho il primo, vado a prendere il secondo
                - se ho il secondo, vado a prendere il primo
                - se non ho nessuno dei 2 prendo quello che necessita spazio
                    minore per prenderlo e posarlo
                
                - setta ID con il numero dell'oggetto scelto
                - setta itemChosen a true per indicare che è stato scelto un oggetto
*/
void scelgoQuale(int obj)
{
    float obj1[3], obj2[3],d1,d2;
    if (game.itemInZone(obj)) {
		//Ho il primo, vado a prendere secondo 
		ID=obj+1;
    } 
    else{	//potrei avere il secondo o nessuno dei 2
		if (game.itemInZone(obj+1)) {
			//Ho il secondo, vado a prendere il primo
			ID=obj;
		}
		else {		//non ne ho nessuno dei 2
			// Leggiamo la posizione degli oggetti dello stesso tipo
	    	game.getItemLoc(obj1, obj);
    		game.getItemLoc(obj2, obj+1);
        	// Verifichiamo per quale dei 2 oggetti dello stesso tipo si percorre
        	// meno spazio come distanza noi-oggetto-zona di assemblaggio
    		if ((dist(obj1,stato)+dist(obj1, zona)) < (dist(obj2,stato)+dist(obj2, zona)))
				ID=obj;
			else 
				ID=obj+1;
		} 
    }
    
    itemChosen = true;
}

//FUNZIONE PER LO SGANCIO DI UN OGGETTO
/*
-input: non assume alcun valore in input
-output: indica se il drop è riuscito
-descrizione:   _Si inizializza un vettore "obj", al quale verrÃ  attribuito costantemente la posizione dell'oggetto "ID"
                _Settiamo il vettore "vai" tramite la funzione "setV" con le coordinate della zona di scarico
                _Se la distanza tra la zona di scarico e l'oggetto Ã¨ minore di 0.045m:
                
                _Viene rilasciato l'oggetto e itemChosen torna a "falso", poichÃ¨ l'oggetto scelto ora Ã¨ stato scaricato
                    e di conseguenza dobbiamo sceglierne uno nuovo
                    
                _Altrimenti non succede nulla
*/
bool dropItem()
{
    float obj[3];
    setV(vai, zona[0], zona[1], zona[2]);
    game.getItemLoc(obj, ID);
    
    if (dist(vai, obj) <0.05)
    {
        game.dropItem();
        itemChosen = false;
        return true;
    }
    else
    	return false;
}
//FUNZIONE PER L'INIZIALIZZAZIONE DELLE VARIABILI
/*
-input: non assume alcun valore in input
-output: non ritorna alcun valore in output
-descrizione: _Viene utilizzata per l'inizializzazione delle variabili globali
*/
void init()
{
    //Azzero vai
    for (int i = 0; i < 3; i++)
        vai[i]=0;
    
   
    //Prelevo il mio stato
	api.getMyZRState(stato);
	
	//Capisco quale sfera siamo
	BoR = stato[1] > 0 ? 1 : 0;     //1 = Blu / 0 = Rossa
	
	//Inizializzo le variabili
	fase = sottofase = 0;
	itemChosen = false;
	counter=0;
	distPrec=999;
	
}
//Funzione per l'applicazione della strategia e delle funzioni
void loop()
{
    //Prelevo i dati all'inizio dello switch
    getDati();
    //Lo siwtch controlla il drop degli sps
    switch(fase){
        //case 0: Droppo gli sps alla posizione stabilita tramite setV()
        case 0:
            switch(sottofase){
	            //Drop del primo SPS
            	case 0:
                	game.dropSPS();
                	DEBUG (("Primo SPS"));
                	sottofase++;
                	//Calcolo dove mettere il secondo SPS
                	if(BoR) {
                    	setV(vai,-0.3,-0.5,0);  //Blu
                    	/*
                    	//Coordinate del giallo 0
                    	game.getItemLoc(vai, 1);
                    	if (vai[2]>0)   //giallo con z positivo
                    	    //Mette il massimo Z negativo
                    	    vai[2]=-0.5;
                    	else
                    	    //Mette il massimo Z positivo
                    	    vai[2]=0.5;
                    	*/
                	}
                	else 
						setV(vai,0.3,0.5,0);    //Rosso
                	//setV(vai, -0.25, 0.45, .0); **Alternativo
            		break;
	            //Drop del secondo SPS se sono nelle vicinanze del punto prefissato
            	case 1:
					if (dist(vai,stato) <0.1)
            		{
                		game.dropSPS();
                		DEBUG (("Secondo SPS"));
                		sottofase++;
                		if(BoR) setV(vai,-0.3,0.5,0.3);
                        else setV(vai,0.3,-0.5,-0.3);
                		/*
                		// Cerco il LARGE più vicino 
                		// Sgancerò il terzo SPS lì
    		            //itemPriority();
    		            ID=0;
    		            itemChosen=true;
            		    game.getItemLoc(vai, ID);
                		fase++;
                		sottofase=0;
                		*/
					}
					break;
					//Droppo il terzo SPS
                case 2:
                    if (dist(vai,stato) < 0.1)
                    {
                        game.dropSPS();
                        DEBUG (("Terzo SPS"));
                        // Preleva i dati della zona
                        game.getZone(zona);
                        sottofase = 0;      //Riazzero la sottofase -> Viene utilizzato in fase2
                        fase++;             //Cambio fase
                    }
                    break;
			}
            break;
        case 1:
 			switch(sottofase){
	            //Vado a prendere un oggetto
            	case 0:
	                //Se non ho scelto un oggetto e lo devo ancora scegliere, eseguo l'itemPriority
    	            if (!itemChosen)
        	           itemPriority();
            	    DEBUG(("ID: %d", ID));
               
                	if (game.hasItem(ID) == 0)
                    	if (dock())     //Tento di fare il docking;se ci riesco vado a posarlo in zona di assembleaggio
                        	sottofase++;
                	else
                		if (game.hasItem(ID) == 2)
                			itemChosen=false;	//l'oggetto verso cui andavamo è stato preso dall'avversario
                
					break;
				//Vado a posare l'oggetto	
				case 1:
					if (dropItem())
						//Porto sottofase a a 0 quando l'ho posato, per ricomincaire con un altro oggetto
						sottofase=0;
					break;
			}
            //}
            break;
       
        default:    DEBUG(("ERROR"));
    }
    DEBUG (("/x:%f y:%f z:%f \n/ vel: %f \n/ fase: %d sottofase: %d", vai[0], vai[1], vai[2], speed, fase,sottofase));
 
    muovi(fase,sottofase);    //Si muove verso vai[]
}
